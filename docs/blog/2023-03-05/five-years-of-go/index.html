<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
		<meta
			name="viewport"
			content="width=device-width, initial-scale=1, maximum-scale=1" />

		<title>Five years of Go</title>

		 
		<meta property="og:title" content="Five years of Go" />
		
		<meta property="og:type" content="website" />
		
		<meta property="og:author" content="Chris Amico" />
		
		<meta property="og:url" content="https://chrisamico.com" />
		
		<meta property="og:description" content="Journalist &amp; programmer" />
		  
		<link
			rel="stylesheet"
			href="../../../static/normalize.css?t=1688213615.6234853" />
		<link
			rel="stylesheet"
			href="../../../static/site.css?t=1688213615.6234853" />

		<link rel="alternate" href="../../../blog.rss" />
		<link rel="alternate" href="../../../links.rss" />
		    
		<!-- Global site tag (gtag.js) - Google Analytics -->
		<script
			async
			src="https://www.googletagmanager.com/gtag/js?id=UA-1576645-1"></script>
		<script>
			window.dataLayer = window.dataLayer || [];
			function gtag() {
				dataLayer.push(arguments);
			}
			gtag("js", new Date());
			gtag("config", "UA-1576645-1");
		</script>
		
	</head>
	<body>
		<div class="container">
			
			<header id="about" class="left">
				<div class="fixed">
					<h1>Chris Amico</h1>
					<h2 class="tagline quiet">Journalist &amp; programmer</h2>

					<ul class="social">
						<li class="github">
							<a href="https://github.com/eyeseast" class="icon-github">Github</a>
						</li>
						<li class="linkedin">
							<a href="https://www.linkedin.com/in/chrisamico/" class="icon-linkedin">LinkedIn</a>
						</li>
						<li class="mastodon">
							<a class="icon-mastodon" rel="me" href="https://journa.host/@chrisamico"
								>Mastodon</a
							>
						</li>
						<li class="blog">
							<a href="/blog/">Blog archive</a>
						</li>
						<li class="portfolio">
							<a href="/portfolio/">Portfolio</a>
						</li>
						<li class="github">
							<a class="icon-github" href="https://github.com/eyeseast/chrisamico.com"
								>View source</a
							>
						</li>
					</ul>
				</div>
			</header>

			 
<article id="post" class="right">
	<h1>Five years of Go</h1>

	<div class="metadata">
		<p><time>Mar 05, 2023</time></p>
	</div>
	<div class="content"><p>I&rsquo;d never written a line of Go when I started at Gannett in 2018. I&rsquo;d barely even looked at the language, and when I did it looked both verbose and intimidating. But my team&rsquo;s primary codebase was written in Go, and it was (at the time) the recommended approach to building web services in the company. After half a decade of regularly working in Go, there&rsquo;s a lot I&rsquo;ve come to like about it, and a few things I still struggle with.</p>
<p>Before learning Go, I&rsquo;d worked in Python, JavaScript and PHP, so much of my experience with Go is shaped by how it&rsquo;s different from those languages.</p>
<p>Despite my initial hesitation, Go was relatively easy to learn. It&rsquo;s a small language with great documentation. I went through <a href="https://go.dev/tour/">A tour of Go</a> in a day (partially on my phone), and <a href="https://go.dev/doc/effective_go.html">Effective Go</a> gave me a broad conceptual understanding of the language.</p>
<h2>Types are OK, actually</h2>
<p>I&rsquo;d never used a strongly typed, compiled language before Go. The first langauge I learned was Python, and I was used to writing functions that might handle any kind of data I passed in, and might return a different type depending on the situation. I&rsquo;m not saying that&rsquo;s a good idea, but Python allows it.</p>
<div class="codehilite"><pre><span></span><code><span class="c1"># totally valid, not very good python</span>
<span class="k">def</span> <span class="nf">take_anything</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># a list</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;format&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;list&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="c1"># a string</span>
    <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;format&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="c1"># a tuple</span>
    <span class="k">return</span> <span class="n">args</span>
</code></pre></div>

<p>Go won&rsquo;t compile anything like that, at least not without writing code that makes it very clear we&rsquo;re dealing with a container of unknown length, holding an unknown type. And if we want to use that type, we&rsquo;re going to have to deal with those unknowns.</p>
<p>Over time, I&rsquo;ve come to appreciate that checking types at build time removes a whole class of bugs I&rsquo;d otherwise find much later, when a user somehow passed in something I hadn&rsquo;t anticipated. Now I add type hints to Python and JavaScript out of habit.</p>
<h2>Keep your tools together</h2>
<p>One of Go&rsquo;s selling points is that it compiles quickly. We had a large, multipackage codebase with lots of dependencies, and yet it compiled in a second or two. Go&rsquo;s compiler is fast enough that it&rsquo;s normal to use <code>go run main.go</code> in development &ndash; letting Go build a binary and then run it &ndash; rather than compiling first and running separately.</p>
<p>Alongside the compiler, Go includes a code formatter (<code>go fmt</code>), test suite (<code>go test</code>) and package manager (<code>go mod</code>) in its default toolset. I wrote a very long post about how I install Python. My version of that for Go is one line:</p>
<div class="codehilite"><pre><span></span><code>brew<span class="w"> </span>install<span class="w"> </span>go
</code></pre></div>

<p>I&rsquo;ve come to love tools like Black and Prettier because it removes the mental overhead of formatting &ndash; and deciding <em>how</em> to format &ndash; my code. I write fast and the formatting cleans it up. But Black and Prettier are third-party tools that need to be installed, and a team has to agree to use them. Go has <code>go fmt</code> by default.</p>
<h2>Easier, if not easy, async</h2>
<p>Python was (arguably) late to async. Node.js had it from the beginning, but promises significantly improved the experience. Go has channels and <a href="https://go.dev/tour/concurrency/1">goroutines</a> built into the language in a way I immediately liked. I didn&rsquo;t use it often, but when I needed to parallelize a process, it was easier to reason about than a lot of other tools I&rsquo;ve used. <a href="https://go.dev/doc/effective_go#concurrency">Sharing by communicating</a> is a pattern I understand.</p>
<h2>Go is better now than five years ago</h2>
<p>Using <code>go mod</code> is great, but it&rsquo;s also relatively new. When I started writing Go, we used <code>dep</code> and other tools to manage dependencies. Every package lived on a system-level <code>$GOPATH</code>, alongside our code. Modules and tools to manage different versions of dependencies didn&rsquo;t arrive until Go 1.11.</p>
<p><a href="https://go.dev/doc/tutorial/generics">Generics</a> are another big addition to Go, and it&rsquo;s a new enough part of the language that I&rsquo;ve never actually used it. I probably could&rsquo;ve refactored a lot of my codebase to use generics, but I never made the time. When I was first learning Go, I kept looking for something like Python&rsquo;s <code>itertools</code> in the standard library. I <em>think</em> generics will fill that hole.</p>
<p>Another small feature I love: <a href="https://pkg.go.dev/embed@go1.20.1"><code>embed</code></a>. Let&rsquo;s say I need a large SQL query that I&rsquo;d rather write in its own file. I often write code like this in Python:</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">pathlib</span>

<span class="n">SQL</span> <span class="o">=</span> <span class="p">(</span><span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span> <span class="o">/</span> <span class="s1">&#39;query.sql&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">read_text</span><span class="p">()</span>
</code></pre></div>

<p>Or in Node.js:</p>
<div class="codehilite"><pre><span></span><code><span class="k">import</span><span class="w"> </span><span class="s2">&quot;fs&quot;</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;node:fs&quot;</span>
<span class="k">import</span><span class="w"> </span><span class="s2">&quot;path&quot;</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;node:path&quot;</span>

<span class="kd">const</span><span class="w"> </span><span class="nx">SQL</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="nx">path</span><span class="p">.</span><span class="nx">resolve</span><span class="p">(</span><span class="s1">&#39;./query.sql&#39;</span><span class="p">))</span>
</code></pre></div>

<p>In both cases, I&rsquo;m reading a file, synchronously, at runtime. Yes, it&rsquo;s only doing that once, but it&rsquo;s still a thing the code has to do at runtime. Go can use the <code>embed</code> package to do it at build time.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nx">_</span><span class="w"> </span><span class="s">&quot;embed&quot;</span>

<span class="c1">//go:embed query.sql</span>
<span class="kd">var</span><span class="w"> </span><span class="nx">sql</span><span class="w"> </span><span class="kt">string</span>

<span class="nb">print</span><span class="p">(</span><span class="nx">sql</span><span class="p">)</span>
</code></pre></div>

<h2>It&rsquo;s a weird syntax</h2>
<p>Even after five years with Go, I still find myself looking up basic things, like how to read files or use parts of the standard library. There are great resources, like <a href="https://gobyexample.com/">Go by Example</a>, but it&rsquo;s still not an intuitive language.</p>
<p>Little things like capitalizing variables to export, or using curly braces where other languages use parentheses, or returning errors still force me to stop and remember how the language works. It&rsquo;s just different enough from every other language I work in that I have to think about it every time.</p>
<p>All that said, I like it and expect to keep using, even if it&rsquo;s not part of my regular job.</p></div>

	<div class="end">
		<a href="../../index.html">Blog</a> |
		<a href="../../../portfolio/index.html">Portfolio</a> |
		<a href="../../../index.html">Home</a>
	</div>
</article>

		</div>

		
	</body>
</html>